% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/is_new_episode.R
\name{is_new_episode}
\alias{is_new_episode}
\title{Determine (new) episodes for patients}
\usage{
is_new_episode(x, episode_days = 365, ...)
}
\arguments{
\item{x}{vector of dates (class \code{Date} or \code{POSIXt})}

\item{episode_days}{length of the required episode in days, defaults to 365. Every element in the input will return \code{TRUE} after this number of days has passed since the last included date, independent of calendar years. Please see \emph{Details}.}

\item{...}{arguments passed on to \code{\link[=as.Date]{as.Date()}}}
}
\value{
a \link{logical} vector
}
\description{
This function determines which items in a vector can be considered (the start of) a new episode, based on the parameter \code{episode_days}. This can be used to determine clinical episodes for any epidemiological analysis.
}
\details{
Dates are first sorted from old to new. The oldest date will mark the start of the first episode. After this date, the next date will be marked that is at least \code{episode_days} days later than the start of the first episode. From that second marked date on, the next date will be marked that is at least \code{episode_days} days later than the start of the second episode which will be the start of the third episode, and so on. Before the vector is being returned, the original order will be restored.

The \code{dplyr} package is not required for this function to work, but this function works conveniently inside \code{dplyr} verbs such as \code{\link[=filter]{filter()}}, \code{\link[=mutate]{mutate()}} and \code{\link[=summarise]{summarise()}}.
}
\section{Experimental lifecycle}{

\if{html}{\figure{lifecycle_experimental.svg}{options: style=margin-bottom:5px} \cr}
The \link[=lifecycle]{lifecycle} of this function is \strong{experimental}. An experimental function is in early stages of development. The unlying code might be changing frequently. Experimental functions might be removed without deprecation, so you are generally best off waiting until a function is more mature before you use it in production code. Experimental functions are only available in development versions of this \code{AMR} package and will thus not be included in releases that are submitted to CRAN, since such functions have not yet matured enough.
}

\section{Read more on our website!}{

On our website \url{https://msberends.github.io/AMR/} you can find \href{https://msberends.github.io/AMR/articles/AMR.html}{a comprehensive tutorial} about how to conduct AMR analysis, the \href{https://msberends.github.io/AMR/reference/}{complete documentation of all functions} and \href{https://msberends.github.io/AMR/articles/WHONET.html}{an example analysis using WHONET data}. As we would like to better understand the backgrounds and needs of our users, please \href{https://msberends.github.io/AMR/survey.html}{participate in our survey}!
}

\examples{
# `example_isolates` is a dataset available in the AMR package.
# See ?example_isolates.

is_new_episode(example_isolates$date)
is_new_episode(example_isolates$date, episode_days = 60)

if (require("dplyr")) {
  # is_new_episode() can also be used in dplyr verbs to determine patient
  # episodes based on any (combination of) grouping variables:
  example_isolates \%>\%
    mutate(condition = sample(x = c("A", "B", "C"), 
                              size = 2000,
                              replace = TRUE)) \%>\% 
    group_by(condition) \%>\%
    mutate(new_episode = is_new_episode(date))
  
  example_isolates \%>\%
    group_by(hospital_id) \%>\% 
    summarise(patients = n_distinct(patient_id),
              n_episodes_365 = sum(is_new_episode(date, episode_days = 365)),
              n_episodes_60  = sum(is_new_episode(date, episode_days = 60)),
              n_episodes_30  = sum(is_new_episode(date, episode_days = 30)))
    
    
  # grouping on patients and microorganisms leads to the same results
  # as first_isolate():
  x <- example_isolates \%>\%
    filter(first_isolate(., include_unknown = TRUE))
    
  y <- example_isolates \%>\%
    group_by(patient_id, mo) \%>\%
    filter(is_new_episode(date))

  identical(x$patient_id, y$patient_id)
  
  # but is_new_episode() has a lot more flexibility than first_isolate(),
  # since you can now group on anything that seems relevant:
  example_isolates \%>\%
    group_by(patient_id, mo, hospital_id, ward_icu) \%>\%
    mutate(flag_episode = is_new_episode(date))
}
}
